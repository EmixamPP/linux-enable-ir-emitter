#include <iostream>
#include <optional>
#include <string>
#include <unistd.h>
using namespace std;

#include <argparse/argparse.hpp>

#include "command/commands.hpp"
#include "utils/logger.hpp"

/**
 * @brief Exit if the program was not run with root privilege.
 */
static void check_root()
{
    if (geteuid() != 0)
        Logger::critical(ExitCode::ROOT_REQUIRED, "Please run with root privilege.");
}

int main(int argc, char **argv)
{
    argparse::ArgumentParser program("linux-enable-ir-emitter", "@version@", argparse::default_arguments::help);
    program.add_description("Provides support for infrared cameras.");
    program.add_epilog("https://github.com/EmixamPP/linux-enable-ir-emitter");

    program.add_argument("-V", "--version")
        .help("shows version message and exits")
        .action([](const auto &)
                {
            cout << "linux-enable-ir-emitter @version@" << endl;
            cout << "Developped by Maxime Dirksen - EmixamPP" << endl;
            cout << "MIT License" << endl;
            exit(ExitCode::SUCCESS); });

    program.add_argument("-d", "--device")
        .help("specify the camera, nothing for automatic")
        .default_value("")
        .nargs(1)
        .metavar("device");
    program.add_argument("-w", "--width")
        .help("specify the width, -1 automatic")
        .default_value(-1)
        .scan<'i', int>()
        .nargs(1)
        .metavar("width");
    program.add_argument("-t", "--height")
        .help("specify the height, -1 for automatic")
        .default_value(-1)
        .scan<'i', int>()
        .nargs(1)
        .metavar("height");
    program.add_argument("-v", "--verbose")
        .help("enables verbose information")
        .flag()
        .action([](const auto &)
                { Logger::enable_debug(); });

    argparse::ArgumentParser configure_command("configure", "@version@", argparse::default_arguments::help);
    configure_command.add_argument("-m", "--manual")
        .help("enables manual verification")
        .flag();
    configure_command.add_argument("-e", "--emitters")
        .help("specify the number of emitters")
        .default_value(1)
        .scan<'i', int>()
        .nargs(1)
        .metavar("emitters");
    configure_command.add_argument("-l", "--limit")
        .help("specify the negative answer limit, use -1 for unlimited")
        .default_value(10)
        .scan<'i', int>()
        .nargs(1)
        .metavar("limit");
    configure_command.add_argument("-g", "--no-gui")
        .help("disables video feedback")
        .flag();
    program.add_subparser(configure_command);

    argparse::ArgumentParser run_command("run", "@version@", argparse::default_arguments::help);
    program.add_subparser(run_command);

    argparse::ArgumentParser tweak_command("tweak", "@version@", argparse::default_arguments::help);
    program.add_subparser(tweak_command);

    argparse::ArgumentParser test_command("test", "@version@", argparse::default_arguments::help);
    program.add_subparser(test_command);

    try
    {
        program.parse_args(argc, argv);
    }
    catch (const exception &e)
    {
        cerr << e.what() << endl;
        cerr << program;
        return ExitCode::FAILURE;
    }

    auto device = program.get<string>("device").empty() ? optional<string>() : program.get<string>("device");
    auto width = program.get<int>("width");
    auto height = program.get<int>("height");

    if (program.is_subcommand_used(configure_command))
    {
        auto manual = configure_command.get<bool>("manual");
        auto emitters = static_cast<unsigned>(configure_command.get<int>("emitters"));
        auto limit = static_cast<unsigned>(configure_command.get<int>("limit"));
        auto no_gui = configure_command.get<bool>("no-gui");
        check_root();
        return configure(device, width, height, manual, emitters, limit, no_gui);
    }
    else if (program.is_subcommand_used(run_command))
        return run(device, width, height);
    else if (program.is_subcommand_used(tweak_command))
    {
        check_root();
        return tweak(device, width, height);
    }
    else if (program.is_subcommand_used(test_command))
        return test(device, width, height);

    cerr << "Subcommand choice is missing" << endl;
    cerr << program;
    return ExitCode::FAILURE;
}
